//****************************************************************************//Copyright © 2005-2006. Adobe Macromedia Software LLC. All rights reserved.//The following Code is subject to all restrictions //contained in the End User License Agreement accompanying//this product.//****************************************************************************import mx.core.View;import mx.core.UIComponent;import mx.controls.Button;import AdobeCaptivate.quiz.CpLabel;import AdobeCaptivate.quiz.CpButton;import AdobeCaptivate.quiz.CpReviewArea;import AdobeCaptivate.quiz.utils.CpItemParams;import AdobeCaptivate.quiz.utils.CpCaptionParams;import AdobeCaptivate.quiz.CpQuizInterface;import mx.utils.Delegate;[Event("next")][Event("back")][Event("submit")][Event("hit")][Event("clear")]class AdobeCaptivate.quiz.CpQuizView extends View implements CpQuizInterface{	// These are required for createClassObject()	static var symbolName:String = "CpQuizView";	static var symbolOwner:Object = AdobeCaptivate.quiz.CpQuizView;	// Version string//#include "../core/ComponentVersion.as"	var className:String = "CpQuizView";		static  var QUESTION:String = "QUESTION";	static  var QUESTIONTITLE:String = "QUESTIONTITLE";	static  var SUBMIT:String = "SUBMIT";	static  var NEXT:String = "NEXT";	static  var BACK:String = "BACK";	static  var CLEAR:String = "CLEAR";	static  var REVIEWAREA:String = "REVIEWAREA";	static  var PROGRESSINDICATOR:String = "PROGRESSINDICATOR";	static  var SUCCESSCAPTION:String = "SUCCESSCAPTION";	static  var FAILURECAPTION:String = "FAILURECAPTION";	static  var FAILURECAPTION_N:String = "FAILURECAPTION_";	static  var RETRYCAPTION:String = "RETRYCAPTION";	static  var INCOMPLETECAPTION:String = "INCOMPLETECAPTION";	static  var TIMEOUTCAPTION:String = "TIMEOUTCAPTION";	static var BLANK:Number = 0;	static var CORRECT:Number = 1;	static var INCORRECT:Number = 2;	static var INCOMPLETE:Number = 3;	static var SHORTANSWER:Number = 1;	static var FILLTHEBLANK:Number = 2;	static var MULTIPLECHOICE:Number = 3;	static var TRUEFALSE:Number = 4;	static var MATCHING:Number = 5;	static var LIKERT:Number = 6;		/***	Setting up predefined depths, so that these components remain the same depth order,	irrespective of their creation order.	***/	private var depthHitButton; 	private var depthTimeout;	private var depthSuccessCaption;	private var depthFailureCaption:Array;	private var depthRetryCaption;	private var depthIncompleteCaption;		private var _slideType:Number = -1;		private var _timeoutCaption:MovieClip = undefined;	//private var _timeoutLabel:TextField = undefined;	private var timeoutMessage:String = "";		private var hit_btn:Button = undefined;	private var itemsColl:Object;	private var _captionParams:Array;		private var _numFailureCaptions;			function mytraceQV(str:String)	{		//trace("CpQuizView---" + str);	}	/*** @private* constructor for the quiz view*/	function CpQuizView()	{			_captionParams = new Array();		depthHitButton = 999; 		depthTimeout = 998;		depthSuccessCaption = 997;		depthFailureCaption = new Array();		depthFailureCaption[0] = 996;		depthFailureCaption[1] = 995;		depthFailureCaption[2] = 994;		depthFailureCaption[3] = 993;		depthRetryCaption = 992;		depthIncompleteCaption = 991;		_numFailureCaptions = 0;	}/*** @private* initialize variables*/	private function init():Void	{		itemsColl = new Object();		super.init();			}	/*** @private* create the children*/	private function createChildren(Void):Void	{		super.createChildren();	}		/*** @public* initialize the component item* creates the default objects, like hit button/time out*/	public function cpInit(Void):Void	{		createHitButton();		createTimeoutCaption();	}/*** @public* create the question item* if linkageID is given then label is ignored, * and it tries to load the MC referred by linageID*/	public function createQuestion(label:String, linkageID:String, x:Number, y:Number, width:Number, height:Number):Void	{		if(itemsColl[QUESTION] != undefined)			return;					var param:CpItemParams = new CpItemParams();		itemsColl[QUESTION] = param;		param._name = QUESTION;		if(linkageID != null && linkageID.length > 0)		{			param._movie = true;			param._component = createChild( linkageID, "question_mc");		}		else		{			param._font.name = "Arial";		param._font.size = 20;		param._font.bBold = true;			param._component = createChild( "CpLabel", "question_lbl", {text: label, hAlign: "center", vAlign: "center"});		}		setItemCoordinates(QUESTION, x, y, width, height);	}/*** @public* create the question Title item* if linkageID is given then label is ignored, * and it tries to load the MC referred by linageID*/	public function createQuestionTitle(label:String, linkageID:String, x:Number, y:Number, width:Number, height:Number):Void	{		if(itemsColl[QUESTIONTITLE] != undefined)			return;		var param:CpItemParams = new CpItemParams();		itemsColl[QUESTIONTITLE] = param;		param._name = QUESTIONTITLE;		if(linkageID != null && linkageID.length > 0)		{			param._movie = true;			param._component = createChild( linkageID, "questionTitle_mc");		}		else		{			param._font.name = "Arial";		param._font.size = 20;		param._font.bBold = true;			param._component = createChild( "CpLabel", "questionTitle_lbl", {text: label, hAlign: "center", vAlign: "center"});		}		setItemCoordinates(QUESTIONTITLE, x, y, width, height);	}/*** @public* create the submit button* if linkageID is given then label is ignored, * and it tries to load the MC referred by linageID*/	public function createSubmitButton(label:String, linkageID:String, x:Number, y:Number, width:Number, height:Number):Void	{		if(itemsColl[SUBMIT] != undefined)			return;		var param:CpItemParams = new CpItemParams();		itemsColl[SUBMIT] = param;		param._name = SUBMIT;		param._component = createChild( "Button", "submit_btn", {label: label});		if(linkageID != null && linkageID.length > 0)		{			var comp:Button = Button(param._component);			comp.icon = linkageID;		}		param._component.addEventListener("click", Delegate.create(this,submit));		param._component.useHandCursor = true;		setItemCoordinates(SUBMIT, x, y, width, height);	}/*** @public* create the next button* if linkageID is given then label is ignored, * and it tries to load the MC referred by linageID*/	public function createNextButton(label:String, linkageID:String, x:Number, y:Number, width:Number, height:Number):Void	{		if(itemsColl[NEXT] != undefined)			return;		var param:CpItemParams = new CpItemParams();		itemsColl[NEXT] = param;		param._name = NEXT;		param._component = createChild( "Button", "next_btn", {label: label});		if(linkageID != null && linkageID.length > 0)		{			var comp:Button = Button(param._component);			comp.icon = linkageID;		}		param._component.addEventListener("click", Delegate.create(this,next));		param._component.useHandCursor = true;		setItemCoordinates(NEXT, x, y, width, height);	}/*** @public* create the back button* if linkageID is given then label is ignored, * and it tries to load the MC referred by linageID*/	public function createBackButton(label:String, linkageID:String, x:Number, y:Number, width:Number, height:Number):Void	{		if(itemsColl[BACK] != undefined)			return;		var param:CpItemParams = new CpItemParams();		itemsColl[BACK] = param;		param._name = BACK;		param._component = createChild( "Button", "back_btn", {label: label});		if(linkageID != null && linkageID.length > 0)		{			var comp:Button = Button(param._component);			comp.icon = linkageID;		}		param._component.addEventListener("click", Delegate.create(this,back));		param._component.useHandCursor = true;		setItemCoordinates(BACK, x, y, width, height);	}/*** @public* create the clear button* if linkageID is given then label is ignored, * and it tries to load the MC referred by linageID*/	public function createClearButton(label:String, linkageID:String, x:Number, y:Number, width:Number, height:Number):Void	{		if(itemsColl[CLEAR] != undefined)			return;		var param:CpItemParams = new CpItemParams();		itemsColl[CLEAR] = param;		param._name = CLEAR;		param._component = createChild( "Button", "clear_btn", {label: label});		if(linkageID != null && linkageID.length > 0)		{			var comp:Button = Button(param._component);			comp.icon = linkageID;		}		param._component.addEventListener("click", Delegate.create(this,clearans));		param._component.useHandCursor = true;		setItemCoordinates(CLEAR, x, y, width, height);	}/*** @public* create the review area of type CpReviewArea*/	public function createReviewArea(x:Number, y:Number, width:Number, height:Number):Void	{		if(itemsColl[REVIEWAREA] != undefined)			return;		var param:CpItemParams = new CpItemParams();		itemsColl[REVIEWAREA] = param;		param._font.name = "Arial";		param._font.size = 12;		param._name = REVIEWAREA;		param._component = createChild( "CpReviewArea", "reviewArea_cpra");		setItemCoordinates(REVIEWAREA, x, y, this.width, height);		param._component._visible = false;		param._component.useHandCursor = true;	}/*** @public* create the progress Indicator* if linkageID is given then label is ignored, * and it tries to load the MC referred by linageID*/	public function createProgressInd(label:String, x:Number, y:Number, width:Number, height:Number):Void	{		if(itemsColl[PROGRESSINDICATOR] != undefined)			return;		var param:CpItemParams = new CpItemParams();		itemsColl[PROGRESSINDICATOR] = param;		param._name = PROGRESSINDICATOR;		param._font.name = "Arial";		param._font.size = 14;		param._font.bBold = true;		param._component = createChild( "CpLabel", "progressInd_lbl", {text: label, hAlign: "left", vAlign: "center"});		setItemCoordinates(PROGRESSINDICATOR, x, y, width, height);	}/*** @public* create the success caption* if linkageID is given then label is ignored, * and it tries to load the MC referred by linageID*/	public function createSuccessCaption(label:String, linkageID:String, audioID:String, x:Number, y:Number, width:Number, height:Number):Void	{		if(itemsColl[SUCCESSCAPTION] != undefined)			return;		var param:CpCaptionParams = new CpCaptionParams();				itemsColl[SUCCESSCAPTION] = param;		param._name = SUCCESSCAPTION;		var _d:Number = depth;		depth = depthSuccessCaption;		if(linkageID != null && linkageID.length > 0)		{			param._movie = true;			param._component = createChild( linkageID, "successCaption_mc");		}		else		{			param._font.name = "Arial";		param._font.size = 20;		param._font.bBold = true;			param._component = createChild( "CpLabel", "successCaption_lbl", {text: label, hAlign: "center", vAlign: "center"});		}		depth = _d;		//param._component._visible = false;		setItemCoordinates(SUCCESSCAPTION, x, y, width, height);		param.audioID = audioID;		addCaptionParams(param); 	}/*** @public* create the failure caption* if linkageID is given then label is ignored, * and it tries to load the MC referred by linageID*/	public function createFailureCaption(label:String, linkageID:String, audioID:String, failureLevel:Number, x:Number, y:Number, width:Number, height:Number):Void	{		if(failureLevel < 0)			failureLevel = 0;		var capString:String = FAILURECAPTION_N + failureLevel;				//trace("capString = " + capString);		if(itemsColl[capString] != undefined)			return;		var param:CpCaptionParams = new CpCaptionParams();		itemsColl[capString] = param;		param._name = FAILURECAPTION;		param._failureLevel = failureLevel;				var _d:Number = depth;		depth = depthFailureCaption[failureLevel];		if(linkageID != null && linkageID.length > 0)		{			param._movie = true;			param._component = createChild( linkageID, "failureCaption_mc_" + failureLevel.toString());		}		else		{			param._font.name = "Arial";		param._font.size = 20;		param._font.bBold = true;			param._component = createChild( "CpLabel", "failureCaption_lbl_" + failureLevel.toString(), {text: label, hAlign: "center", vAlign: "center"});		}		depth = _d;		//param._component._visible = false;		_numFailureCaptions++;		setItemCoordinates(capString, x, y, width, height);		param.audioID = audioID;		addCaptionParams(param);	}	/*** @public* create the retry Caption* if linkageID is given then label is ignored, * and it tries to load the MC referred by linageID*/	public function createRetryCaption(label:String, linkageID:String, audioID:String, x:Number, y:Number, width:Number, height:Number):Void	{		if(itemsColl[RETRYCAPTION] != undefined)			return;		var param:CpCaptionParams = new CpCaptionParams();		itemsColl[RETRYCAPTION] = param;		param._name = RETRYCAPTION;		var _d:Number = depth;		depth = depthRetryCaption;		if(linkageID != null && linkageID.length > 0)		{			param._movie = true;			param._component = createChild( linkageID, "retryCaption_mc");		}		else		{			param._font.name = "Arial";		param._font.size = 20;		param._font.bBold = true;			param._component = createChild( "CpLabel", "retryCaption_lbl", {text: label, hAlign: "center", vAlign: "center"});		}		//param._component._visible = false;		setItemCoordinates(RETRYCAPTION, x, y, width, height);		depth = _d;		param.audioID = audioID;		addCaptionParams(param);	}/*** @public* create the incomplete caption* if linkageID is given then label is ignored, * and it tries to load the MC referred by linageID*/	public function createIncompleteCaption(label:String, linkageID:String, audioID:String, x:Number, y:Number, width:Number, height:Number):Void	{		if(itemsColl[INCOMPLETECAPTION] != undefined)			return;		var param:CpCaptionParams = new CpCaptionParams();		itemsColl[INCOMPLETECAPTION] = param;		param._name = INCOMPLETECAPTION;		var _d:Number = depth;		depth = depthIncompleteCaption;				if(linkageID != null && linkageID.length > 0)		{			param._movie = true;			param._component = createChild( linkageID, "incompleteCaption_mc");		}		else		{			param._font.name = "Arial";		param._font.size = 20;		param._font.bBold = true;			param._component = createChild( "CpLabel", "incompleteCaption_lbl", {text: label, hAlign: "center", vAlign: "center"});		}		depth = _d;		//param._component._visible = false;		setItemCoordinates(INCOMPLETECAPTION, x, y, width, height);		param.audioID = audioID;		addCaptionParams(param);	}/*** @private* create the submit button* if linkageID is given then label is ignored, * and it tries to load the MC referred by linageID*/	private function createTimeoutCaption()	{		var param:CpCaptionParams = new CpCaptionParams();		_timeoutCaption = createEmptyMovieClip("_timeout_mc", depthTimeout);		_timeoutCaption.createTextField("_timeout_lbl", _timeoutCaption.getNextHighestDepth(), 0, 0, 100, 20);//.createLabel("_timeoutLabel",timeoutCaption.getNextHighestDepth());		//trace("_timeoutLabel = " + _timeoutCaption["_timeout_lbl"]);		//_timeoutCaption["_timeout_lbl"]		_timeoutCaption._visible = false;		param._component = _timeoutCaption;		param._name = TIMEOUTCAPTION;		addCaptionParams(param);	}	// if we get invalidated just call super	function invalidate(Void):Void	{		super.invalidate();	}	// redraw by re-laying out	function draw(Void):Void	{		size();	}	// respond to size changes	function size(Void):Void	{		super.size();	}/*** @private* override this to find out when a new object is added that needs to be layed out* @param object the layout object*/	function addLayoutObject(object:Object):Void	{	}	function initLayout():Void	{		super.initLayout();	}/****/	private function addCaptionParams(param:CpCaptionParams)	{		_captionParams.push(param);	}		//function setReviewMessages(correctMsg, incompleteMsg, incorrectMsg_0, incorrectMsg_1)	function setReviewMessages(reviewMessages:Array)	{		var comp:CpReviewArea = CpReviewArea(getQuizItem(REVIEWAREA));		//comp.setMessages(correctMsg, incompleteMsg, incorrectMsg_0, incorrectMsg_1);		comp.setMessages(reviewMessages[0], reviewMessages[1], reviewMessages[2], reviewMessages[3]);	}		function setTimeoutMessage(msg:String)	{		timeoutMessage = msg;		//createTimeoutCaption();	}/*********		private function hideAllFeedbacks()	{		setItemVisible(SUCCESSCAPTION, false);		setItemVisible(RETRYCAPTION, false);		setItemVisible(FAILURECAPTION, false);		setItemVisible(INCOMPLETECAPTION, false);	}		//the function displays the feedback asked for.	//it returns true if feedback is shown successfully, otherwise returns false	function showFeedback(feedback:String):Boolean	{		hideLastFeedback();		var bStatus:Boolean = false;		if(feedback.toLowerCase() == "success")		{			bStatus = setItemVisible(SUCCESSCAPTION, true);			m_lastFeedback = SUCCESSCAPTION;		}		else if(feedback.toLowerCase() == "retry")		{			bStatus = setItemVisible(RETRYCAPTION, true);			m_lastFeedback = RETRYCAPTION;		}		else if(feedback.toLowerCase() == "failure")		{			bStatus = setItemVisible(FAILURECAPTION, true);			m_lastFeedback = FAILURECAPTION;		}		else if(feedback.toLowerCase() == "incomplete")		{			bStatus = setItemVisible(INCOMPLETECAPTION, true);			m_lastFeedback = INCOMPLETECAPTION;		}		return bStatus;	}		function hideLastFeedback()	{		setItemVisible(m_lastFeedback, false);	}		function getLastFeedback():String	{		return m_lastFeedback;	}		function enableBackButton(e:Boolean)	{		var p:CpItemParams = itemsColl[BACK];		if(p != undefined)	p._component.enabled = e;	}	function enableNextButton(e:Boolean)	{		var p:CpItemParams = itemsColl[NEXT];		if(p != undefined)	p._component.enabled = e;	}	function enableClearButton(e:Boolean)	{		var p:CpItemParams = itemsColl[CLEAR];		if(p != undefined)	p._component.enabled = e;	}		function enableSubmitButton(e:Boolean)	{		var p:CpItemParams = itemsColl[SUBMIT];		if(p != undefined)	p._component.enabled = e;	}****/	//set the font of progressindicator	function setProgressIndFont(fontName:String, fontColor:Number, fontSize:Number, bBold:Boolean, bItalic:Boolean)	{		setItemFont(PROGRESSINDICATOR, fontName, fontSize, fontColor, bBold, bItalic);	}	//returns true if successfully done otherwise false	function setItemVisible(item:String, bVisible:Boolean):Boolean	{		var p:CpItemParams;		p = getItemParams(item);		if(p != undefined)		{			p._component._visible = bVisible;			invalidate();			return true;		}		return false;	}	//set the item text	function setItemText(item:String, newText:String):Void	{		var p:CpItemParams;		p = getItemParams(item);		p._component.text = newText;		invalidate();	}	//set the font and color of item	function setItemFont(item:String, fontFamily:String, fontSize:Number, fontColor:Number, bBold:Boolean, bItalic:Boolean)	{		var p:CpItemParams;		p = getItemParams(item);		p._font.name = fontFamily;		p._font.size = fontSize;		p._font.color = fontColor;		p._font.bBold = bBold;		p._font.bItalic = bItalic;		invalidate();	}	//set the text and new style of text	function setItemTextTF(item:String, newText:String, fontFamily:String, fontSize:Number, fontColor:Number, bBold:Boolean, bItalic:Boolean)	{		setItemText(item, newText);		setItemFont(item, fontFamily, fontSize, fontColor, bBold, bItalic);	}		//set the box of item	function setItemCoordinates(item:String, x:Number, y:Number, w:Number, h:Number)	{		setItemPos(item, x, y);		setItemSize(item, w, h);	}		//resize the item	function setItemSize(item:String, width:Number, height:Number):Void	{		var p:CpItemParams;		p = getItemParams(item);		p._width = width;		p._height = height;			setBoundaries(p);		invalidate();	}	//move item to new pos	function setItemPos(item:String, x:Number, y:Number):Void	{		var p:CpItemParams;		p = getItemParams(item);		p._x = x;		p._y = y;			setBoundaries(p);		invalidate();	}	function createHitButton()	{		if(hit_btn == undefined)		{			var _d:Number = getNextHighestDepth();			depth = depthHitButton;			createChild("Button", "hit_btn");			depth = _d;			hit_btn._visible = false;			hit_btn.addEventListener("click", Delegate.create(this,hit));		}	}/*********	function showHitButton()	{		enableSubmitButton(false);		enableClearButton(false);		if(hit_btn == undefined)		{			createChild("Button", "hit_btn");			hit_btn.addEventListener("click", Delegate.create(this,hit));		}	}***********/	function showTimeOver()	{		//hideAllFeedbacks();		//showHitButton();		createChild("CpLabel", "timeoutLabel", {text:""});		invalidate();	}/*always override this function, so that setitem* function works correctly*/	private function getItemParams(item:String):CpItemParams	{		return itemsColl[item.toUpperCase()];	}/*** @private* override this to layout the content*/	function doLayout():Void	{		var p:CpItemParams = itemsColl[QUESTION];		if(p != undefined)		setItemParams(p._component, p);		//trace(typeof p._component);				p = itemsColl[QUESTIONTITLE];		if(p != undefined)			setItemParams(p._component, p);		//trace(" x = " + p._x + " y = " + p._y + " comp = " + p._component);		//trace(typeof p._component);		p = itemsColl[SUBMIT];		if(p != undefined)		setItemParams(p._component, p);				p = itemsColl[NEXT];		if(p != undefined)		setItemParams(p._component, p);				p = itemsColl[BACK];		if(p != undefined)		setItemParams(p._component, p);		p = itemsColl[CLEAR];		if(p != undefined)		setItemParams(p._component, p);		p = itemsColl[REVIEWAREA];		if(p != undefined)		setItemParams(p._component, p);		p = itemsColl[PROGRESSINDICATOR];		if(p != undefined)		setItemParams(p._component, p);		p = itemsColl[SUCCESSCAPTION];		if(p != undefined)		setItemParams(p._component, p);		for(var index:Number = 0; index < _numFailureCaptions; index++)		{			p = itemsColl[FAILURECAPTION_N + index];			if(p != undefined)		setItemParams(p._component, p);		}				p = itemsColl[RETRYCAPTION];		if(p != undefined)		setItemParams(p._component, p);		p = itemsColl[INCOMPLETECAPTION];		if(p != undefined)		setItemParams(p._component, p);		if(_timeoutCaption != undefined && _timeoutCaption._visible)			setTimerLabelParams();		if(hit_btn != undefined)		{			hit_btn.move(0, 0);			hit_btn.setSize(width, height);			hit_btn._alpha = 0;			hit_btn.useHandCursor = true;		}				super.doLayout();	}/*** @private* sets the location of timer label* */	private function setTimerLabelParams()	{		//_timeoutCaption["_timeout_lbl"].setStyle("fontFamily", "Arial");		//_timeoutCaption["_timeout_lbl"].setStyle("fontSize", 24);		_timeoutCaption["_timeout_lbl"].multiline = true;		_timeoutCaption["_timeout_lbl"].wordWrap = true;		_timeoutCaption["_timeout_lbl"].selectable = false;		_timeoutCaption["_timeout_lbl"].text = timeoutMessage;		var my_fmt:TextFormat = new TextFormat();		my_fmt.color = 0x000000;		my_fmt.font = "Arial";		my_fmt.size = 16;		_timeoutCaption["_timeout_lbl"].setTextFormat(my_fmt);				var w:Number = 140;		var h:Number = 70;		var x:Number = width - _timeoutCaption["_timeout_lbl"].width - 10;		var y:Number = 40;		var p:CpItemParams = itemsColl[FAILURECAPTION];		if(p == undefined)			p = itemsColl[SUCCESSCAPTION];		if(p == undefined)			p = itemsColl[INCOMPLETECAPTION];		if(p == undefined)			p = itemsColl[RETRYCAPTION];		if(p != undefined)		{			w = (w > p._width) ? w : p._width;			h = (h > p._height) ? h : p._height;			x = p._x;			y = p._y;		}		else		{			p = itemsColl[SUBMIT];			x = p._x;			y = p._y - h - 10;			if(y < 0) y = 0;		}		_timeoutCaption["_timeout_lbl"].setSize(w, h);		_timeoutCaption._x = x;		_timeoutCaption._y = y;		//trace("_timeout_lbl = " + _timeoutCaption["_timeout_lbl"]);		//trace("timeoutMessage = " + _timeoutCaption["_timeout_lbl"].text);		//trace("_timeoutCaption._x = " + _timeoutCaption._x + " _timeoutCaption._y = " + _timeoutCaption._y);		//trace("_timeoutCaption._width = " + _timeoutCaption._width + " _timeoutCaption._height = " + _timeoutCaption._height); 	}		function setItemParams(comp1:MovieClip, params:CpItemParams)	{		if(params._movie == true)		{			setMovieItemParams(params._component, params);			return;		}		var comp:UIComponent = UIComponent(comp1);		comp.setSize(params._width, params._height);		comp.move(params._x, params._y);		comp.setStyle("fontFamily", params._font.name);		comp.setStyle("fontSize", params._font.size);		comp.setStyle("fontStyle", params._font.bItalic?"italic":"normal");		comp.setStyle("fontWeight", params._font.bBold?"bold":"normal");		comp.setStyle("color", params._font.color);		//comp.setStyle("backgroundColor", 0xFF00FF);	}	function setMovieItemParams(comp:MovieClip, params:CpItemParams)	{		comp._x = params._x;		comp._y = params._y;	}	function setBoundaries(params:Object):Void	{		if(params._x < 2)			params._x = 2;		if(params._y < 2)			params._y = 2;		if(params._width < 10)		params._width = 10;		if(params._height < 10)		params._height = 10;				if(params._width > (width - 2))			params._width = width - params._x;		if(params._height > (height - 2))			params._height = height - params._y;		if((params._x + params._width) > (width - 2))			params._x = width - 2 - params._width;		if((params._y + params._height) > (height - 2))			params._y = height - 2 - params._height;	}			function getQuizItem(item:String):UIComponent	{		return itemsColl[item.toUpperCase()]._component;	}	private function clearAll() {		 //overloaded in subclass	}	//dispatch the events	private function next(evt)    {   dispatchEvent({type:"next", name:evt.target, target:this});    }	private function back(evt)    {   dispatchEvent({type:"back", name:evt.target, target:this});    }	private function submit(evt)  {   dispatchEvent({type:"submit", name:evt.target, target:this});    }	private function clearans(evt)  {   clearAll(); dispatchEvent({type:"clear", name:evt.target, target:this});    }	private function hit(evt)  {   dispatchEvent({type:"hit", name:evt.target, target:this});    }	//get the items	function get successCaption():MovieClip	{ return itemsColl[SUCCESSCAPTION]._component;	}	function get failureCaption():MovieClip	{ return itemsColl[FAILURECAPTION]._component;	}	function get retryCaption():MovieClip	{ return itemsColl[RETRYCAPTION]._component;	}	function get incompleteCaption():MovieClip	{ return itemsColl[INCOMPLETECAPTION]._component;	}	function get timeoutCaption():MovieClip	{ return _timeoutCaption;	}	function get captionParams():Array { return _captionParams; }	function get reviewArea():MovieClip { return itemsColl[REVIEWAREA]._component; }	function get submitButton():Button { return itemsColl[SUBMIT]._component; }	function get clearButton():Button { return itemsColl[CLEAR]._component; }	function get hitButton():Button { return hit_btn; }	function get answerParams():Array { 		//overloaded in subclass		return null; 	}	function get slideType():Number { return _slideType; }	function set slideType(type:Number) { _slideType = type; }		public function showChild(mc:MovieClip, vs:Boolean)	{ 		//trace("mc to show = " + mc); 		mc._visible = vs; invalidate(); 	}/** The subclasses must override these functions so that it controller refers to correct* version of functions*/	function submitAns() {	}	function getUserAnswers():Array { return undefined; }	function getStatus():Number { return undefined; }			var clipParameters:Object = { };/*** @private* all components must use this mechanism to merge their clip parameters with their base class clip parameters*/	static var mergedClipParameters:Boolean = UIObject.mergeClipParameters(CpQuizView.prototype.clipParameters, View.prototype.clipParameters);}